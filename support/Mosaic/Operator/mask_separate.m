%% SEPARATE MASK OPERATOR
%
% Description:
% Given the mask generated by the function load_mask, returns a separate
% mask for the HR and the LR mask; as a prerequisite, it is necessary that
% the masks are non overlapping.


function out=mask_separate(I_mosaic,mask_in)

if isfield(I_mosaic,'data'), I_mosaic=I_mosaic.data; end
if isfield(mask_in,'data'), mask=mask_in.data; else, mask=mask_in; end
if isfield(mask_in,'ratio'), ratio=mask_in.ratio; else, ratio=[1,1]; end
if length(ratio)==1, ratio=[ratio,ratio]; end
if isfield(mask_in,'padding'), padding=mask_in.padding; else, padding=[0,0,0,0]; end
if isfield(mask_in,'shift'), shift=mask_in.shift; else, shift=zeros(size(mask,3),2); end
if isfield(mask_in,'start_pos'), start_pos=mask_in.start_pos; else, start_pos=floor(ratio/2+1); end
if isfield(mask_in,'band_HR'), band_HR=mask_in.band_HR; else, band_HR=0; end

if isempty(mask)
    out.mask_EXP=[];
    out.image_EXP=I_mosaic(:,:,band_HR+1:end);
    out.mask_LR=[];
    out.image_LR=out.image_EXP(start_pos(1):ratio(1):end,start_pos(2):ratio(2):end,:);
    out.mask_HR=[];
    out.image_HR=I_mosaic(:,:,1:band_HR);
    out.mosaic_HR=out.image_HR;
    out.mosaic_LR=out.image_LR;
    return;
end

I_mosaic=repmat(I_mosaic,[1,1,size(mask,3)]);
for kk=1:size(mask,3)
    I_mosaic(:,:,kk)=circshift(I_mosaic(:,:,kk),-shift(kk,:));
    mask(:,:,kk)=circshift(mask(:,:,kk),-shift(kk,:));
end
mask=mask(padding(1)+1:end-padding(3),padding(2)+1:end-padding(4),:);
I_mosaic=I_mosaic(padding(1)+1:end-padding(3),padding(2)+1:end-padding(4),:);

tol=10E-9*max(abs(mask(:)));
mask_idxnonzero=mask>tol;

sum_mask=sum(mask,3);
I_out=zeros(size(mask));
for kk=1:size(mask,3)
    mask_current=mask(:,:,kk);
    I_current=I_mosaic(:,:,kk);
    I_temp=zeros(size(I_current));
    I_temp(mask_idxnonzero(:,:,kk))=I_current(mask_idxnonzero(:,:,kk))./mask_current(mask_idxnonzero(:,:,kk)).*sum_mask(mask_idxnonzero(:,:,kk));
    I_out(:,:,kk)=I_temp;
end
mask=double(mask_idxnonzero);

mask_HR=mask(:,:,1:band_HR);
image_HR=I_out(:,:,1:band_HR);
mask_EXP=mask(:,:,band_HR+1:end);
image_EXP=I_out(:,:,band_HR+1:end);

mask_LR=imfilter(mask_EXP,ones(ratio),'circular');
mask_LR=mask_LR(1:ratio(1):end,1:ratio(2):end,:);

image_LR=imfilter(image_EXP,ones(ratio),'circular');
image_LR=image_LR(1:ratio(1):end,1:ratio(2):end,:);

mask_LR_idxnonzero=mask_LR>=1;

for kk=1:size(mask_LR,3)
    mask_LR_current=mask_LR(:,:,kk);
    I_current=image_LR(:,:,kk);
    I_temp=zeros(size(I_current));
    I_temp(mask_LR_idxnonzero(:,:,kk))=I_current(mask_LR_idxnonzero(:,:,kk))./mask_LR_current(mask_LR_idxnonzero(:,:,kk));
    image_LR(:,:,kk)=I_temp;
end

out.mask_EXP=mask_EXP;
out.image_EXP=image_EXP;
out.mask_LR=double(mask_LR_idxnonzero);
out.image_LR=image_LR;
out.mask_HR=mask_HR;
out.image_HR=image_HR;

if isempty(image_HR), out.mosaic_HR=[]; else, out.mosaic_HR=sum(mask_HR.*image_HR,3); end
if isempty(image_LR), out.mosaic_LR=[]; else, out.mosaic_LR=sum(mask_LR.*image_LR,3); end

